---
phase: 02-execution-control
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/coordinator/PlayerStateCoordinator.ts
  - src/services/PlayerBackgroundService.ts
autonomous: true

must_haves:
  truths:
    - "Coordinator execute* methods fire when state transitions occur (executePlay, executePause, executeStop, executeLoadTrack)"
    - "observerMode can be toggled at runtime for instant Phase 1 rollback"
    - "BGS remote play/pause/duck handlers only dispatch events — no direct side effects (applySmartRewind, _setLastPauseTime)"
    - "Smart rewind fires exactly once per remote play action, not twice"
  artifacts:
    - path: "src/services/coordinator/PlayerStateCoordinator.ts"
      provides: "Fixed executeTransition that calls execute* methods; observerMode runtime toggle"
      contains: "setObserverMode"
    - path: "src/services/PlayerBackgroundService.ts"
      provides: "Clean remote handlers that only dispatch events"
  key_links:
    - from: "PlayerStateCoordinator.handleEvent"
      to: "PlayerStateCoordinator.executeTransition"
      via: "nextState passed as parameter, not re-read from this.context.currentState"
      pattern: "executeTransition.*event.*nextState"
    - from: "PlayerStateCoordinator.executeTransition"
      to: "PlayerService.executePlay"
      via: "switch on nextState parameter"
      pattern: "playerService\\.executePlay"
    - from: "PlayerBackgroundService.handleRemotePlay"
      to: "dispatchPlayerEvent"
      via: "dispatch only, no applySmartRewind before dispatch"
      pattern: "dispatchPlayerEvent.*PLAY"
---

<objective>
Fix the coordinator's executeTransition bug so execute* methods actually fire, make observerMode a runtime toggle, and remove duplicate side effects from BGS remote handlers.

Purpose: The coordinator skeleton already exists but a critical bug prevents it from executing — `executeTransition` compares `nextState` against an already-updated `this.context.currentState`, making the guard always false. Additionally, BGS handlers duplicate side effects (applySmartRewind, \_setLastPauseTime) that execute\* methods also perform, causing double-execution. These two fixes together satisfy EXEC-01, EXEC-02, EXEC-04, and EXEC-05.

Output: Working coordinator execution with clean BGS event dispatch.
</objective>

<execution_context>
@/Users/clay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/clay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-execution-control/02-RESEARCH.md
@src/services/coordinator/PlayerStateCoordinator.ts
@src/services/PlayerBackgroundService.ts
@src/services/PlayerService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix executeTransition bug and add observerMode runtime toggle</name>
  <files>src/services/coordinator/PlayerStateCoordinator.ts</files>
  <action>
Three changes to PlayerStateCoordinator.ts:

**1. Fix the executeTransition guard (CRITICAL BUG — line 575)**

The guard `if (nextState && nextState !== this.context.currentState)` is always false because `handleEvent` sets `this.context.currentState = nextState` on line 258 BEFORE calling `executeTransition` on line 262. This means executePlay(), executePause(), executeStop(), executeLoadTrack() NEVER fire.

Fix: Remove the incorrect guard inside `executeTransition`. The method is already only called when `validation.allowed === true` (guarded in `handleEvent`), so no additional guard is needed. Replace the state-transition block:

```typescript
// BEFORE (broken):
if (nextState && nextState !== this.context.currentState) {
  switch (nextState) { ... }
}

// AFTER (fixed):
if (nextState) {
  switch (nextState) { ... }
}
```

This is the simplest correct fix. `executeTransition` is only reachable when `validation.allowed === true`, so the transition has already been validated. The `nextState` null-check is sufficient — if `nextState` is non-null, execute the corresponding method.

**2. Make observerMode a runtime toggle (line 75)**

Change:

```typescript
private readonly observerMode = false;
```

To:

```typescript
private observerMode = false;
```

Add a public setter method after `isObserverMode()` (around line 165):

```typescript
/**
 * Set observer mode at runtime.
 * When true, coordinator observes but does not execute (Phase 1 behavior).
 * When false, coordinator calls service execute* methods (Phase 2+ behavior).
 */
setObserverMode(enabled: boolean): void {
  this.observerMode = enabled;
  log.info(`[Coordinator] Observer mode ${enabled ? 'enabled' : 'disabled'}`);
}
```

**3. Update Phase 1 comments to reflect Phase 2 status**

Update the file header comment (lines 1-23) to reflect Phase 2 status. Change "Phase 1: Observer Mode" to "Phase 2: Execution Control" in the class comment. Update the dispatch() JSDoc (line 121) to remove "In Phase 1" wording. Update handleEvent() JSDoc (line 197) similarly.

Do NOT change:

- `transitions.ts` — no changes needed
- `eventBus.ts` — no changes needed
- The constructor log message can be updated to say "Execution Mode" instead of "Observer Mode" but should also log when observerMode is true
  </action>
  <verify>
  Run: `npm test -- --testPathPattern="PlayerStateCoordinator" --no-coverage`

Existing tests should pass. Specifically:

- "should be in execution mode" test at line 427 should still pass (observerMode still defaults to false)
- "should execute state transitions in execution mode" test at line 431 should still pass
- All state transition tests should pass

Also verify TypeScript compiles: `npx tsc --noEmit --pretty 2>&1 | head -20`
</verify>
<done>

- The `executeTransition` method no longer has the broken `nextState !== this.context.currentState` guard
- `observerMode` is no longer `readonly` and has a `setObserverMode()` public method
- All existing coordinator tests pass
- TypeScript compiles without errors
  </done>
  </task>

<task type="auto">
  <name>Task 2: Remove duplicate side effects from BGS remote handlers</name>
  <files>src/services/PlayerBackgroundService.ts</files>
  <action>
Remove side effects from BGS handlers that are already performed by the coordinator's execute* methods. The coordinator now calls `playerService.executePlay()` which does `applySmartRewind()` and `_setLastPauseTime(null)`, and `playerService.executePause()` which does `_setLastPauseTime(pauseTime)`. BGS must NOT duplicate these.

**1. Clean up `handleRemotePlay()` (lines 100-114)**

Remove `applySmartRewind()` call (line 107) and `store._setLastPauseTime(null)` (lines 110-111). The handler should only dispatch the event. Remove the `TrackPlayer.getProgress()` call (line 101) since it was only used for `applySmartRewind()`.

After:

```typescript
async function handleRemotePlay(): Promise<void> {
  log.debug(`RemotePlay received (${describeRuntimeContext()})`);
  dispatchPlayerEvent({ type: "PLAY" });
}
```

Remove the `applySmartRewind` import if it's no longer used by any remaining function in this file. Check: `handleRemoteDuck` also uses it — see step 3.

**2. Clean up `handleRemotePause()` (lines 119-126)**

Remove `store._setLastPauseTime(pauseTime)` (lines 121-124). The coordinator calls `playerService.executePause()` which handles this.

After:

```typescript
async function handleRemotePause(): Promise<void> {
  log.debug(`RemotePause received (${describeRuntimeContext()})`);
  dispatchPlayerEvent({ type: "PAUSE" });
}
```

**3. Clean up `handleRemoteDuck()` resume branch (lines 336-381)**

In the `else` branch (resume from duck, around line 358), remove `applySmartRewind()` (line 359) and `store._setLastPauseTime(null)` (lines 361-362). The coordinator will handle these via `executePlay()`.

In the `if (event.permanent)` branch (line 345), remove `store._setLastPauseTime(pauseTime)` (lines 346-348). The coordinator will handle this via `executePause()`.

In the `else if (event.paused)` branch (line 351), remove `store._setLastPauseTime(pauseTime)` (lines 352-354). The coordinator will handle this via `executePause()`.

After these changes, check if `applySmartRewind` is still imported anywhere in the file. If not, remove the import (line 13). Also check if `useAppStore` is still needed in `handleRemoteDuck` — if the only use was `_setLastPauseTime`, the `store` variable may need cleanup. But `useAppStore` is still used extensively in other handlers so keep the import.

**DO NOT** modify these handlers:

- `handleRemoteJumpForward` / `handleRemoteJumpBackward` — their `progressService.updateProgress()` and `store.updatePosition()` calls are NOT duplicated by `executeSeek()` (which only calls `TrackPlayer.seekTo()`). These are progress tracking, not playback execution. Leave them alone.
- `handleRemoteSeek` — same reason as above
- `handleRemoteStop` — its `progressService.endCurrentSession()` call is progress cleanup, not duplicated by `executeStop()`
- `handlePlaybackStateChanged` — this dispatches `NATIVE_STATE_CHANGED`, not `PLAY`/`PAUSE`
- `handlePlaybackProgressUpdated` — this dispatches `NATIVE_PROGRESS_UPDATED`, not execution events
  </action>
  <verify>
  Run: `npm test -- --no-coverage`

All tests should pass. There are no direct unit tests for BGS handlers, but the coordinator tests confirm execution works end-to-end.

Verify the `applySmartRewind` import can be removed if no remaining usage:
Search the file for `applySmartRewind` — if it appears only in the import line and nowhere else, remove the import.

Also verify TypeScript compiles: `npx tsc --noEmit --pretty 2>&1 | head -20`
</verify>
<done>

- `handleRemotePlay()` only dispatches `{ type: "PLAY" }` — no `applySmartRewind()`, no `_setLastPauseTime()`
- `handleRemotePause()` only dispatches `{ type: "PAUSE" }` — no `_setLastPauseTime()`
- `handleRemoteDuck()` dispatches `PLAY`/`PAUSE` events without duplicating side effects
- `applySmartRewind` import removed if no longer used in the file
- All tests pass
- TypeScript compiles without errors
  </done>
  </task>

</tasks>

<verification>
1. Run full test suite: `npm test -- --no-coverage` — all tests pass
2. TypeScript check: `npx tsc --noEmit` — no errors
3. Verify executeTransition fix: In `PlayerStateCoordinator.ts`, the switch on `nextState` inside `executeTransition` is NOT guarded by `nextState !== this.context.currentState`
4. Verify observerMode toggle: `setObserverMode()` method exists and `observerMode` is not `readonly`
5. Verify BGS cleanup: `handleRemotePlay` does not contain `applySmartRewind` or `_setLastPauseTime`
6. Verify BGS cleanup: `handleRemotePause` does not contain `_setLastPauseTime`
7. Verify BGS cleanup: `handleRemoteDuck` does not contain `applySmartRewind` or `_setLastPauseTime` (in the PLAY/PAUSE branches)
</verification>

<success_criteria>

- The executeTransition bug is fixed: execute\* methods fire on valid state transitions
- observerMode is toggleable at runtime via setObserverMode()
- BGS remote handlers only dispatch events, not duplicate side effects
- All existing tests pass
- TypeScript compiles cleanly
  </success_criteria>

<output>
After completion, create `.planning/phases/02-execution-control/02-01-SUMMARY.md`
</output>
