---
phase: 03-position-reconciliation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/coordinator.ts
  - src/services/coordinator/PlayerStateCoordinator.ts
autonomous: true

must_haves:
  truths:
    - "MIN_PLAUSIBLE_POSITION (5s) and LARGE_DIFF_THRESHOLD (30s) are exported from a single shared location, not hardcoded inline"
    - "Coordinator has a resolveCanonicalPosition(libraryItemId) method that returns position + source using the same priority chain as the old determineResumePosition()"
    - "When isLoadingTrack is true and NATIVE_PROGRESS_UPDATED arrives with position 0, context.position is NOT overwritten"
    - "When isLoadingTrack is true and NATIVE_PROGRESS_UPDATED arrives with position > 0, context.position IS updated (real progress, not the 0-before-loaded case)"
    - "When isLoadingTrack is false, all NATIVE_PROGRESS_UPDATED positions (including 0) update context.position normally"
  artifacts:
    - path: "src/types/coordinator.ts"
      provides: "Shared position reconciliation constants and ResumePositionInfo type"
      contains: "MIN_PLAUSIBLE_POSITION"
    - path: "src/services/coordinator/PlayerStateCoordinator.ts"
      provides: "resolveCanonicalPosition method and native-0 guard in updateContextFromEvent"
      contains: "resolveCanonicalPosition"
  key_links:
    - from: "src/services/coordinator/PlayerStateCoordinator.ts"
      to: "src/types/coordinator.ts"
      via: "import MIN_PLAUSIBLE_POSITION, LARGE_DIFF_THRESHOLD"
      pattern: "import.*MIN_PLAUSIBLE_POSITION"
    - from: "src/services/coordinator/PlayerStateCoordinator.ts"
      to: "DB helpers (getActiveSession, getMediaProgressForLibraryItem)"
      via: "resolveCanonicalPosition calls DB helpers for position priority chain"
      pattern: "getActiveSession|getMediaProgressForLibraryItem"
---

<objective>
Create the coordinator-owned position reconciliation method and guard native-0 position updates during track loading.

Purpose: The coordinator must own canonical position. Currently, position reconciliation logic lives in PlayerService.determineResumePosition() and is duplicated across files. This plan creates the coordinator-side infrastructure: shared constants, the reconciliation method, and the native-0 guard. Plan 02 will wire the callers and remove the old method.

Output: Coordinator with resolveCanonicalPosition() method and native-0 guard; shared constants in types/coordinator.ts.
</objective>

<execution_context>
@/Users/clay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/clay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-position-reconciliation/03-RESEARCH.md
@src/types/coordinator.ts
@src/services/coordinator/PlayerStateCoordinator.ts
@src/services/PlayerService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract shared constants and types to coordinator types</name>
  <files>src/types/coordinator.ts</files>
  <action>
Add the following exports to the bottom of src/types/coordinator.ts (before the closing of the file):

1. Export `MIN_PLAUSIBLE_POSITION = 5` with JSDoc explaining it's the minimum position (seconds) considered plausible when resuming — positions below this may indicate "not yet loaded" from native player.

2. Export `LARGE_DIFF_THRESHOLD = 30` with JSDoc explaining it's the threshold (seconds) for treating a position discrepancy as "large" — when DB session and saved progress differ by more than this, prefer the more recently updated source.

3. Export the `ResumeSource` type: `"activeSession" | "savedProgress" | "asyncStorage" | "store"`.

4. Export the `ResumePositionInfo` interface with fields: `position: number`, `source: ResumeSource`, `authoritativePosition: number | null`, `asyncStoragePosition: number | null`.

These types currently live as private types in PlayerService.ts (lines 61-68). Moving them to coordinator.ts makes them importable by the coordinator. Do NOT remove them from PlayerService yet — Plan 02 handles that.
</action>
<verify>Run `npx tsc --noEmit` to confirm no type errors. Verify the constants and types are exported: `grep -n "MIN_PLAUSIBLE_POSITION\|LARGE_DIFF_THRESHOLD\|ResumeSource\|ResumePositionInfo" src/types/coordinator.ts`</verify>
<done>MIN_PLAUSIBLE_POSITION, LARGE_DIFF_THRESHOLD, ResumeSource, and ResumePositionInfo are exported from src/types/coordinator.ts with JSDoc comments.</done>
</task>

<task type="auto">
  <name>Task 2: Add resolveCanonicalPosition method and native-0 guard to coordinator</name>
  <files>src/services/coordinator/PlayerStateCoordinator.ts</files>
  <action>
Two changes to PlayerStateCoordinator.ts:

**Change A: Gate NATIVE_PROGRESS_UPDATED position-0 during loading (POS-03)**

In `updateContextFromEvent`, replace the current `NATIVE_PROGRESS_UPDATED` case:

```typescript
case "NATIVE_PROGRESS_UPDATED":
  this.context.position = event.payload.position;
  this.context.duration = event.payload.duration;
  this.context.lastPositionUpdate = Date.now();
  break;
```

With:

```typescript
case "NATIVE_PROGRESS_UPDATED":
  // POS-03: Do not overwrite valid position with native-0 during track load.
  // After TrackPlayer.add(tracks), the native player briefly reports position 0
  // before the seek to the resume position completes. If we write 0 here, we
  // lose the position that resolveCanonicalPosition just resolved.
  // Once isLoadingTrack is cleared (by QUEUE_RELOADED), native 0 is accepted.
  if (this.context.isLoadingTrack && event.payload.position === 0) {
    this.context.duration = event.payload.duration; // duration update is safe
    this.context.lastPositionUpdate = Date.now();
    break;
  }
  this.context.position = event.payload.position;
  this.context.duration = event.payload.duration;
  this.context.lastPositionUpdate = Date.now();
  break;
```

**Change B: Add resolveCanonicalPosition method**

Add a new public async method `resolveCanonicalPosition(libraryItemId: string): Promise<ResumePositionInfo>` to the coordinator class. Place it in a new section between the "Context Management" and "Event Bus Integration" sections, with a header comment `// Position Reconciliation`.

This method replicates the priority logic from PlayerService.determineResumePosition() (lines 647-761). The algorithm:

1. Import at top of file: `getActiveSession` from `@/db/helpers/localListeningSessions`, `getMediaProgressForLibraryItem` from `@/db/helpers/mediaProgress`, `getUserByUsername` from `@/db/helpers/users`, `getStoredUsername` from `@/lib/secureStore`, `ASYNC_KEYS, getItem as getAsyncItem, saveItem` from `@/lib/asyncStore`, and `MIN_PLAUSIBLE_POSITION, LARGE_DIFF_THRESHOLD, ResumePositionInfo, ResumeSource` from `@/types/coordinator`. Also import `useAppStore` from `@/stores/appStore` and `formatTime` from `@/lib/utils`.

2. Method body — same logic as current determineResumePosition():
   - Start with store position as default (source = "store")
   - Read asyncStoragePosition from ASYNC_KEYS.position
   - If asyncStoragePosition exists, use it (source = "asyncStorage")
   - Look up DB user via getStoredUsername() + getUserByUsername()
   - If user found, fetch [activeSession, savedProgress] in parallel
   - If activeSession exists:
     - If sessionPosition < MIN_PLAUSIBLE_POSITION: prefer savedProgress or asyncStorage fallback
     - If savedProgress exists with large diff (> LARGE_DIFF_THRESHOLD): prefer more recent timestamp
     - Otherwise: use session position
   - Else if savedProgress exists: use savedProgress.currentTime
   - If source is still "store", set authoritativePosition = null
   - Return { position, source, authoritativePosition, asyncStoragePosition }

3. After resolving, update `this.context.position` with the resolved position.

4. Dispatch `POSITION_RECONCILED` with the resolved position: `dispatchPlayerEvent({ type: "POSITION_RECONCILED", payload: { position } })`.

5. If authoritativePosition differs from asyncStoragePosition, sync AsyncStorage: `await saveItem(ASYNC_KEYS.position, authoritativePosition)`.

6. Log the resolution source and position using `log.info`.

Key detail: The method must be public because PlayerService.executeLoadTrack() and reloadTrackPlayerQueue() will call it directly (Plan 02). The coordinator already has PlayerService as a dependency (imported for execute\* methods), and PlayerService importing the coordinator creates no new circular dependency because PlayerService already imports dispatchPlayerEvent from the event bus and the coordinator is accessed via getInstance().

Import `dispatchPlayerEvent` from `./eventBus` (already imported indirectly; add direct import if not present).

Do NOT add `import { dispatchPlayerEvent }` if the coordinator doesn't already have it — check first. The coordinator currently receives events via `subscribeToEventBus()` from `playerEventBus`. For dispatching back, import `{ dispatchPlayerEvent }` from `./eventBus`.
</action>
<verify>
Run `npx tsc --noEmit` to confirm no type errors. Run `npm test -- --testPathPattern="coordinator"` to confirm existing coordinator tests still pass. Manually verify:

1. `grep -n "resolveCanonicalPosition" src/services/coordinator/PlayerStateCoordinator.ts` shows the method exists
2. `grep -n "isLoadingTrack.*position.*0" src/services/coordinator/PlayerStateCoordinator.ts` shows the native-0 guard
   </verify>
   <done>Coordinator has resolveCanonicalPosition() method implementing the full position priority chain (DB session > savedProgress > AsyncStorage > store), updates context.position, dispatches POSITION_RECONCILED, and syncs AsyncStorage. The native-0 guard prevents position-0 overwrites during isLoadingTrack=true. All existing tests pass.</done>
   </task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- `npm test -- --testPathPattern="coordinator"` passes (no regression)
- `npm test` passes (full suite, no regression)
- `grep "MIN_PLAUSIBLE_POSITION" src/types/coordinator.ts` returns the constant
- `grep "resolveCanonicalPosition" src/services/coordinator/PlayerStateCoordinator.ts` returns the method
- The NATIVE_PROGRESS_UPDATED case in updateContextFromEvent now has an isLoadingTrack guard
</verification>

<success_criteria>

- Coordinator owns a position reconciliation method with the same priority chain as the old determineResumePosition()
- Native-0 position updates are blocked during track loading (POS-03)
- Shared constants exist in one place (POS-02 foundation)
- All existing tests pass without modification
  </success_criteria>

<output>
After completion, create `.planning/phases/03-position-reconciliation/03-01-SUMMARY.md`
</output>
