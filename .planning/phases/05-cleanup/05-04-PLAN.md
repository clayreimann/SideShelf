---
phase: 05-cleanup
plan: "04"
type: execute
wave: 3
depends_on:
  - "05-03"
files_modified:
  - src/stores/slices/playerSlice.ts
  - src/services/PlayerService.ts
  - src/services/coordinator/__tests__/backgroundRestoration.integration.test.ts
  - src/stores/__tests__/playerSlice.test.ts
autonomous: true
requirements:
  - CLEAN-01
  - CLEAN-02
  - CLEAN-03

must_haves:
  truths:
    - "isRestoringState field is removed from PlayerSliceState interface and initial state"
    - "setIsRestoringState action is removed from playerSlice"
    - "_updateCurrentChapter uses loading.isLoadingTrack guard instead of isRestoringState"
    - "reloadTrackPlayerQueue in PlayerService has no setIsRestoringState calls"
    - "PlayerService.ts line count is under 1,100 lines"
    - "backgroundRestoration integration test still passes (uses isLoadingTrack instead)"
    - "npm test passes with no regressions"
  artifacts:
    - path: "src/stores/slices/playerSlice.ts"
      provides: "playerSlice without isRestoringState field or action"
    - path: "src/services/PlayerService.ts"
      provides: "reloadTrackPlayerQueue without isRestoringState calls; line count <1,100"
    - path: "src/stores/__tests__/playerSlice.test.ts"
      provides: "Updated playerSlice tests without setIsRestoringState describe block"
    - path: "src/services/coordinator/__tests__/backgroundRestoration.integration.test.ts"
      provides: "Background restoration test using _setTrackLoading instead of setIsRestoringState"
  key_links:
    - from: "playerSlice _updateCurrentChapter"
      to: "loading.isLoadingTrack"
      via: "guard check preventing position-0 chapter during queue rebuild"
      pattern: "isLoadingTrack"
---

<objective>
Remove isRestoringState from playerSlice and PlayerService. The coordinator's isLoadingTrack flag provides the same guard after Plan 03 landed chapter detection in the coordinator. This is the last flag removal, completing CLEAN-01 and CLEAN-03 and bringing PlayerService under the 1,100-line target.

Purpose: isRestoringState was a playerSlice-local guard that predates the coordinator. isLoadingTrack (coordinator-managed) is the correct replacement.
Output: playerSlice loses ~25 lines; PlayerService loses ~15 lines; integration test updated to use new guard.
</objective>

<execution_context>
@/Users/clay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/clay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-cleanup/05-RESEARCH.md
@src/stores/slices/playerSlice.ts
@src/services/PlayerService.ts
@src/services/coordinator/__tests__/backgroundRestoration.integration.test.ts
@src/stores/__tests__/playerSlice.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove isRestoringState from playerSlice</name>
  <files>src/stores/slices/playerSlice.ts</files>
  <action>
Remove all isRestoringState references from playerSlice.ts:

**1. Remove from PlayerSliceState interface (line 57-58):**

```typescript
/** Whether we're currently restoring state (prevents premature chapter updates) */
isRestoringState: boolean;
```

Delete these two lines from the `player` object in the interface.

**2. Remove initial value from player state object (line 378 approx):**
Find `isRestoringState: false,` in the initial state object and delete it.

**3. Remove setIsRestoringState action from PlayerSliceActions interface (line 112):**

```typescript
/** Set isRestoringState flag to prevent UI jumping during state restoration */
setIsRestoringState: (isRestoring: boolean) => void;
```

Delete this line and its JSDoc.

**4. Remove setIsRestoringState implementation (lines 585-593):**

```typescript
setIsRestoringState: (isRestoring: boolean) => {
  set((state: PlayerSlice) => ({
    ...state,
    player: {
      ...state.player,
      isRestoringState: isRestoring,
    },
  }));
},
```

Delete this entire method.

**5. Replace isRestoringState guard in \_updateCurrentChapter (lines 481-488):**
Current code:

```typescript
const { currentTrack, currentChapter, isRestoringState } = state.player;

// Skip chapter updates during state restoration to prevent UI jumping
// The correct chapter will be set after restoration completes
if (isRestoringState) {
  log.debug("Skipping chapter update during state restoration");
  return;
}
```

Replace with:

```typescript
const { currentTrack, currentChapter, loading } = state.player;

// Skip chapter updates while track is loading (prevents position-0 chapter during queue rebuild)
// Previously guarded by isRestoringState; now uses coordinator-managed isLoadingTrack (CLEAN-03)
if (loading.isLoadingTrack) {
  log.debug("Skipping chapter update while track is loading");
  return;
}
```

**6. Remove isRestoringState from restorePersistedState (around lines 133-140):**
The `restorePersistedState` method starts by setting `isRestoringState: true`. Find and remove this initial `set()` call that sets isRestoringState to true. The restoration logic itself (AsyncStorage reads, DB reconciliation) is retained — only the isRestoringState flag usage is removed.

After `restorePersistedState` completes, it used to clear isRestoringState. Find and remove that clearing call too (it may be implicit — check if there's a final `setIsRestoringState(false)` call in restorePersistedState).
</action>
<verify> - `grep -n "isRestoringState" src/stores/slices/playerSlice.ts` → 0 results - `grep -n "loading.isLoadingTrack" src/stores/slices/playerSlice.ts` → found in \_updateCurrentChapter - File compiles: check via npm test
</verify>
<done>
isRestoringState is fully removed from playerSlice. \_updateCurrentChapter uses loading.isLoadingTrack as the chapter update guard.
</done>
</task>

<task type="auto">
  <name>Task 2: Remove setIsRestoringState calls from PlayerService + update tests</name>
  <files>
    src/services/PlayerService.ts
    src/stores/__tests__/playerSlice.test.ts
    src/services/coordinator/__tests__/backgroundRestoration.integration.test.ts
  </files>
  <action>
**PlayerService.ts — reloadTrackPlayerQueue cleanup:**

Find `reloadTrackPlayerQueue()` (around line 545). Remove all three `setIsRestoringState` call sites:

1. Before `TrackPlayer.reset()` (line ~552): `tempStore.setIsRestoringState?.(true);` — delete this line.
2. After finding zero tracks (line ~559): `tempStore.setIsRestoringState?.(false);` — delete this line.
3. After `_updateCurrentChapter` call (line ~580): `updatedStore.setIsRestoringState?.(false);` — delete this line.
4. The else branch (position === 0) (line ~584): `updatedStore.setIsRestoringState?.(false);` — delete this line.

The `_updateCurrentChapter(resumeInfo.position)` call (line ~579) is RETAINED — it's still needed to set the correct chapter after queue rebuild. Only the `setIsRestoringState` wrapper calls are deleted.

After deletions, count lines: `wc -l src/services/PlayerService.ts` — must be under 1,100.

If still at or above 1,100, look for:

- Stale inline comments referencing isRestoringState (remove them)
- Duplicate JSDoc blocks (PlayerService has several duplicate comments like "Set playback rate" appearing twice — clean up one duplicate where found)
- The comment around lines 576-577 that says "RETAINED: setIsRestoringState — playerSlice-local guard" — delete this since isRestoringState is now gone

**playerSlice.test.ts — test cleanup:**

1. Find and delete the `describe("setIsRestoringState")` block (around lines 393-400). The entire block tests a method that no longer exists.

2. Find the `_updateCurrentChapter` test that uses `setIsRestoringState(true)` to block chapter updates (around line 266). Update it to use `_setTrackLoading(true)` instead:
   ```typescript
   // Old:
   store.setIsRestoringState(true);
   // New:
   store._setTrackLoading(true);
   ```
   The test expectation (that chapter does NOT update when the guard is active) remains the same.

**backgroundRestoration.integration.test.ts — test update:**

Find the test "should not display stale chapter after foreground restoration" (or similar). It currently uses `setIsRestoringState(true)` to simulate the guard state. Update to use `_setTrackLoading(true)` instead:

```typescript
// Old:
store.setIsRestoringState(true);
// New:
store._setTrackLoading(true);
```

The test behavior (chapter does not update during the guard period) remains identical — only the mechanism changes.

Run: `npm test -- --no-coverage 2>&1 | tail -30`
</action>
<verify> - `grep -rn "setIsRestoringState\|isRestoringState" src/` → 0 results across all source files - `wc -l src/services/PlayerService.ts` → under 1,100 lines - `npm test -- --no-coverage 2>&1 | grep -E "PASS|FAIL|Tests:"` — all pass
</verify>
<done>
isRestoringState is removed from all files. PlayerService.ts is under 1,100 lines. All tests pass including the background restoration integration test which now uses \_setTrackLoading.
</done>
</task>

</tasks>

<verification>
Final grep confirming complete removal:
```
grep -rn "isRestoringState\|setIsRestoringState" src/
```
→ 0 results

Line count target confirmed:

```
wc -l src/services/PlayerService.ts
```

→ under 1,100

Run full test suite:

```
npm test -- --no-coverage 2>&1 | tail -30
```

→ all pass
</verification>

<success_criteria>

- isRestoringState field, action, and all call sites are gone from codebase
- \_updateCurrentChapter uses loading.isLoadingTrack as guard
- PlayerService.ts is under 1,100 lines
- backgroundRestoration integration test passes (updated to \_setTrackLoading)
- playerSlice test updated (setIsRestoringState describe block deleted, \_updateCurrentChapter test uses \_setTrackLoading)
- All tests pass
  </success_criteria>

<output>
After completion, create `.planning/phases/05-cleanup/05-04-SUMMARY.md`
</output>
