---
phase: 02-execution-control
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/services/coordinator/__tests__/PlayerStateCoordinator.test.ts
autonomous: true

must_haves:
  truths:
    - "Exactly one event per coordinator action — execute* methods do not re-dispatch events onto the bus (EXEC-03)"
    - "setObserverMode(true) prevents execute* methods from being called (EXEC-04)"
    - "NATIVE_* events update coordinator context even in observer mode (EXEC-05)"
    - "Coordinator calls executePlay when transitioning to PLAYING state (EXEC-01)"
    - "Coordinator calls executePause when transitioning to PAUSED state (EXEC-01)"
    - "Coordinator calls executeLoadTrack when LOAD_TRACK transitions to LOADING (EXEC-01)"
    - "Coordinator rejects LOAD_TRACK from LOADING state — duplicate session prevention (EXEC-02)"
  artifacts:
    - path: "src/services/coordinator/__tests__/PlayerStateCoordinator.test.ts"
      provides: "Contract tests for execution control, feedback loop prevention, observer mode toggle, and transition guards"
      contains: "feedback loop prevention"
  key_links:
    - from: "PlayerStateCoordinator.executeTransition"
      to: "PlayerService mock"
      via: "jest.fn() spy assertions"
      pattern: "executePlay.*toHaveBeenCalled"
    - from: "playerEventBus.dispatch"
      to: "coordinator event processing"
      via: "spy counting dispatched events"
      pattern: "dispatch.*toHaveBeenCalledTimes"
---

<objective>
Add comprehensive test coverage for Phase 2 execution control: verify execute* methods fire correctly, feedback loops are prevented, observer mode rollback works, and transition guards reject invalid operations.

Purpose: EXEC-03 requires a test suite asserting exactly one event per coordinator action. EXEC-04 requires tests proving observer mode rollback works. The existing test file has execution mode tests but does not verify PlayerService mock calls or feedback loop prevention. This plan adds those critical contract tests.

Output: Test suite with full coverage of EXEC-01 through EXEC-06 requirements.
</objective>

<execution_context>
@/Users/clay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/clay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-execution-control/02-RESEARCH.md
@.planning/phases/02-execution-control/02-01-SUMMARY.md
@src/services/coordinator/__tests__/PlayerStateCoordinator.test.ts
@src/services/coordinator/PlayerStateCoordinator.ts
@src/services/PlayerService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add execution control contract tests (EXEC-01, EXEC-02, EXEC-03)</name>
  <files>src/services/coordinator/__tests__/PlayerStateCoordinator.test.ts</files>
  <action>
Add new `describe` blocks to the existing test file. The file already mocks PlayerService with jest.fn() spies for executeLoadTrack, executePlay, executePause, executeStop, executeSeek, executeSetRate, executeSetVolume (lines 15-31). Use these mocks to verify execution.

**Important:** The existing mock is defined at module scope. To get a reference to the mock instance for assertions, use:

```typescript
const { PlayerService } = require("../../PlayerService");
const mockPlayerService = PlayerService.getInstance();
```

Add this at the top of the new describe blocks, or in beforeEach if needed. Call `jest.clearAllMocks()` in beforeEach to reset call counts.

**Block 1: `describe("execution control (EXEC-01)")` — Verify execute\* methods are called**

Tests:

1. `"should call executeLoadTrack when LOAD_TRACK transitions to LOADING"` — Dispatch `{ type: "LOAD_TRACK", payload: { libraryItemId: "test-item" } }` from IDLE. Wait 50ms. Assert `mockPlayerService.executeLoadTrack` was called with `("test-item", undefined)`.

2. `"should call executePlay when transitioning to PLAYING"` — Setup: dispatch LOAD_TRACK, then QUEUE_RELOADED (IDLE -> LOADING -> READY). Then dispatch PLAY. Wait 50ms. Assert `mockPlayerService.executePlay` was called once.

3. `"should call executePause when transitioning to PAUSED"` — Setup: reach PLAYING state (LOAD_TRACK -> QUEUE_RELOADED -> PLAY). Then dispatch PAUSE. Wait 50ms. Assert `mockPlayerService.executePause` was called once.

4. `"should call executeStop when transitioning to IDLE via STOP"` — Setup: reach PLAYING state. Then dispatch STOP. Wait 50ms. Assert `mockPlayerService.executeStop` was called once.

5. `"should call executeSeek on SEEK event"` — Setup: reach PLAYING state. Dispatch `{ type: "SEEK", payload: { position: 1000 } }`. Wait 50ms. Assert `mockPlayerService.executeSeek` was called with `(1000)`.

6. `"should call executeSetRate on SET_RATE event"` — Setup: reach PLAYING state. Dispatch `{ type: "SET_RATE", payload: { rate: 1.5 } }`. Wait 50ms. Assert `mockPlayerService.executeSetRate` was called with `(1.5)`.

7. `"should call executeSetVolume on SET_VOLUME event"` — Setup: reach PLAYING state. Dispatch `{ type: "SET_VOLUME", payload: { volume: 0.7 } }`. Wait 50ms. Assert `mockPlayerService.executeSetVolume` was called with `(0.7)`.

**Block 2: `describe("transition guards (EXEC-02)")` — Verify invalid operations rejected**

Tests:

1. `"should reject LOAD_TRACK from LOADING state (duplicate session prevention)"` — Dispatch LOAD_TRACK to reach LOADING. Clear mocks. Dispatch another LOAD_TRACK. Wait 50ms. Assert `mockPlayerService.executeLoadTrack` was NOT called (call count 0 after clear). Assert `rejectedTransitionCount` increased.

2. `"should reject PLAY from IDLE state"` — Dispatch PLAY from IDLE. Wait 50ms. Assert `mockPlayerService.executePlay` was NOT called. Assert `rejectedTransitionCount` increased.

3. `"should reject PAUSE from IDLE state"` — Same pattern.

4. `"should reject SEEK from IDLE state"` — Dispatch SEEK from IDLE. Wait 50ms. Assert `mockPlayerService.executeSeek` was NOT called.

**Block 3: `describe("feedback loop prevention (EXEC-03)")` — Verify no event re-dispatch**

Tests:

1. `"should not re-dispatch events from within executePlay"` — Spy on `playerEventBus.dispatch`. Setup: reach READY state. Clear the dispatch spy call count. Dispatch `{ type: "PLAY" }` directly to coordinator (not via bus). Wait 50ms. Assert `playerEventBus.dispatch` was NOT called (call count 0). The coordinator processes the event but execute\* methods must not call `dispatchPlayerEvent`.

2. `"should not re-dispatch events from within executePause"` — Same pattern for PAUSE from PLAYING state.

3. `"should not re-dispatch events from within executeSeek"` — Same pattern for SEEK from PLAYING state.

4. `"should process exactly one event when PLAY dispatched via bus"` — Spy on coordinator's dispatch method. Dispatch PLAY via `playerEventBus.dispatch()`. Wait 50ms. Assert coordinator's dispatch was called exactly once. This ensures no feedback loop where execute* -> dispatchPlayerEvent -> bus -> coordinator -> execute* again.

**Helper function suggestion:** Create a helper at the top of the test file or within the describe block:

```typescript
async function transitionToState(
  coordinator: PlayerStateCoordinator,
  targetState: PlayerState
): Promise<void> {
  if (targetState === PlayerState.LOADING) {
    await coordinator.dispatch({ type: "LOAD_TRACK", payload: { libraryItemId: "test-item" } });
  } else if (targetState === PlayerState.READY) {
    await coordinator.dispatch({ type: "LOAD_TRACK", payload: { libraryItemId: "test-item" } });
    await coordinator.dispatch({ type: "QUEUE_RELOADED", payload: { position: 0 } });
  } else if (targetState === PlayerState.PLAYING) {
    await coordinator.dispatch({ type: "LOAD_TRACK", payload: { libraryItemId: "test-item" } });
    await coordinator.dispatch({ type: "QUEUE_RELOADED", payload: { position: 0 } });
    await coordinator.dispatch({ type: "PLAY" });
  } else if (targetState === PlayerState.PAUSED) {
    await coordinator.dispatch({ type: "LOAD_TRACK", payload: { libraryItemId: "test-item" } });
    await coordinator.dispatch({ type: "QUEUE_RELOADED", payload: { position: 0 } });
    await coordinator.dispatch({ type: "PLAY" });
    await coordinator.dispatch({ type: "PAUSE" });
  }
  await new Promise((resolve) => setTimeout(resolve, 50));
}
```

  </action>
  <verify>
Run: `npm test -- --testPathPattern="PlayerStateCoordinator" --no-coverage`

All tests should pass, including the new execution control, transition guard, and feedback loop prevention tests. Count the new tests — should be at least 14 new tests.
</verify>
<done>

- executePlay/executePause/executeStop/executeLoadTrack/executeSeek/executeSetRate/executeSetVolume mock calls verified
- Duplicate LOAD_TRACK from LOADING rejected (EXEC-02)
- execute\* methods do NOT re-dispatch events (EXEC-03)
- Bus dispatch count stays at exactly 1 per action (EXEC-03)
  </done>
  </task>

<task type="auto">
  <name>Task 2: Add observer mode rollback and NATIVE_* context update tests (EXEC-04, EXEC-05)</name>
  <files>src/services/coordinator/__tests__/PlayerStateCoordinator.test.ts</files>
  <action>
Add two more describe blocks to the test file.

**Block 4: `describe("observer mode rollback (EXEC-04)")` — Verify runtime toggle**

Tests:

1. `"should default to execution mode (observerMode = false)"` — Assert `coordinator.isObserverMode()` is `false`. (This already exists but add for completeness in the EXEC-04 block.)

2. `"should switch to observer mode at runtime via setObserverMode(true)"` — Call `coordinator.setObserverMode(true)`. Assert `coordinator.isObserverMode()` is `true`.

3. `"should NOT call execute* methods when observer mode is enabled"` — Call `coordinator.setObserverMode(true)`. Transition to READY (LOAD_TRACK -> QUEUE_RELOADED). Clear mocks. Dispatch PLAY. Wait 50ms. Assert `mockPlayerService.executePlay` was NOT called. Assert coordinator state still transitions to PLAYING (state machine validation works, just no execution).

4. `"should resume calling execute* methods when observer mode is disabled"` — Call `coordinator.setObserverMode(true)`. Transition to READY. Call `coordinator.setObserverMode(false)`. Clear mocks. Dispatch PLAY. Wait 50ms. Assert `mockPlayerService.executePlay` WAS called.

5. `"should still update context in observer mode (state tracking)"` — Call `coordinator.setObserverMode(true)`. Dispatch LOAD_TRACK. Wait 50ms. Assert context `isLoadingTrack` is `true`. Assert coordinator state is LOADING (state tracking continues in observer mode).

**Block 5: `describe("NATIVE_* context updates (EXEC-05)")` — Verify unconditional updates**

Note: Some of these tests already exist in the "Lock Screen Controls Integration" describe block. The new tests focus on EXEC-05 specifically: context updates happen regardless of observerMode.

Tests:

1. `"should update isPlaying from NATIVE_STATE_CHANGED in execution mode"` — Reach PLAYING state. Dispatch `{ type: "NATIVE_STATE_CHANGED", payload: { state: State.Paused } }`. Wait 50ms. Assert `context.isPlaying` is `false`.

2. `"should update isPlaying from NATIVE_STATE_CHANGED in observer mode"` — Call `coordinator.setObserverMode(true)`. Dispatch LOAD_TRACK, then NATIVE_STATE_CHANGED with State.Playing. Wait 50ms. Assert `context.isPlaying` is `true`.

3. `"should update position from NATIVE_PROGRESS_UPDATED in observer mode"` — Call `coordinator.setObserverMode(true)`. Dispatch `{ type: "NATIVE_PROGRESS_UPDATED", payload: { position: 456, duration: 3600 } }`. Wait 50ms. Assert `context.position` is `456`.

4. `"should update lastError from NATIVE_ERROR in observer mode"` — Call `coordinator.setObserverMode(true)`. Dispatch `{ type: "NATIVE_ERROR", payload: { error: new Error("test") } }`. Wait 50ms. Assert `context.lastError` is not null.

After adding all tests, run the full suite and verify test count increased.
</action>
<verify>
Run: `npm test -- --testPathPattern="PlayerStateCoordinator" --no-coverage`

All tests should pass. Verify:

- New "observer mode rollback" tests: 5 tests
- New "NATIVE\_\* context updates" tests: 4 tests
- Total new tests from both tasks: ~23 new tests
- Zero test failures

Run: `npm test -- --testPathPattern="PlayerStateCoordinator" --coverage` to check coverage of PlayerStateCoordinator.ts is >90%.
</verify>
<done>

- setObserverMode(true) prevents execute\* calls — verified by test
- setObserverMode(false) resumes execute\* calls — verified by test
- Context tracking continues in observer mode — verified by test
- NATIVE\_\* events update context in both execution and observer mode — verified by test
- All tests pass with >90% coverage on coordinator
  </done>
  </task>

</tasks>

<verification>
Run full verification:
1. `npm test -- --no-coverage` — all tests pass (0 failures)
2. `npm test -- --testPathPattern="PlayerStateCoordinator" --coverage` — >90% coverage on PlayerStateCoordinator.ts
3. Verify EXEC-01: grep test file for "executePlay.*toHaveBeenCalled" — exists
4. Verify EXEC-02: grep test file for "duplicate session prevention" or "LOAD_TRACK from LOADING" — exists
5. Verify EXEC-03: grep test file for "feedback loop" — exists and tests pass
6. Verify EXEC-04: grep test file for "setObserverMode" — exists and tests pass
7. Verify EXEC-05: grep test file for "NATIVE_STATE_CHANGED.*observer" — exists and tests pass
8. Verify EXEC-06: all existing "Lock Screen Controls Integration" tests still pass (regression)
</verification>

<success_criteria>

- 20+ new tests added covering EXEC-01 through EXEC-06
- All tests pass
- > 90% coverage on PlayerStateCoordinator.ts
- Feedback loop prevention contract is tested (EXEC-03)
- Observer mode rollback is tested (EXEC-04)
- NATIVE\_\* unconditional updates are tested (EXEC-05)
- Existing lock screen integration tests still pass (EXEC-06)
  </success_criteria>

<output>
After completion, create `.planning/phases/02-execution-control/02-02-SUMMARY.md`
</output>
