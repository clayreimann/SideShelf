---
phase: 05-cleanup
plan: "05"
type: execute
wave: 4
depends_on:
  - "05-04"
files_modified:
  - src/services/coordinator/__tests__/PlayerStateCoordinator.test.ts
autonomous: true
requirements:
  - CLEAN-05
  - CLEAN-06

must_haves:
  truths:
    - "A single integration test covers the full lifecycle: LOAD_TRACK → PLAY → PAUSE → SEEK → PLAY → STOP"
    - "The test verifies each execute* method is called in order"
    - "Post-seek PLAY dispatch (when preSeekState was PLAYING) is verified"
    - "All existing tests continue to pass"
    - "90%+ coverage is maintained across all modified files"
  artifacts:
    - path: "src/services/coordinator/__tests__/PlayerStateCoordinator.test.ts"
      provides: "Full lifecycle integration test in execution control describe block"
      contains: "LOAD_TRACK.*PLAY.*PAUSE.*SEEK.*STOP"
  key_links:
    - from: "full lifecycle integration test"
      to: "executeLoadTrack, executePlay, executePause, executeSeek, executeStop"
      via: "coordinator dispatch sequence with mock PlayerService"
      pattern: "executeLoadTrack.*executePlay.*executePause.*executeSeek.*executeStop"
---

<objective>
Add the full lifecycle integration test covering LOAD_TRACK → PLAY → PAUSE → SEEK → PLAY → STOP. This test is the gate that must pass before the session mutex (Plan 06) can be removed. It also validates the end-to-end coordinator flow post-cleanup.

Purpose: Prove the coordinator correctly sequences all five lifecycle phases through a single test. Required gate for CLEAN-04 (session mutex removal).
Output: One new integration test; all existing tests pass; coverage maintained.
</objective>

<execution_context>
@/Users/clay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/clay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-cleanup/05-RESEARCH.md
@src/services/coordinator/__tests__/PlayerStateCoordinator.test.ts
@src/services/coordinator/PlayerStateCoordinator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add full lifecycle integration test</name>
  <files>src/services/coordinator/__tests__/PlayerStateCoordinator.test.ts</files>
  <action>
Add a new `describe("Full lifecycle integration (CLEAN-05)")` block to the coordinator test file. Place it after the existing PROP-* describe blocks near the end of the file.

The test must cover the complete sequence: LOAD_TRACK → QUEUE_RELOADED → PLAY → NATIVE_STATE_CHANGED(Playing) → NATIVE_PROGRESS_UPDATED (2-3 ticks) → PAUSE → NATIVE_STATE_CHANGED(Paused) → SEEK → NATIVE_PROGRESS_UPDATED(seek position) → PLAY → NATIVE_STATE_CHANGED(Playing) → STOP.

Follow the existing PROP-01 integration test pattern as a template (around line 2197). That test already covers LOAD→PLAY→PROGRESS→PAUSE→STOP. Extend it with SEEK and second PLAY.

**Test structure:**

```typescript
describe("Full lifecycle integration (CLEAN-05)", () => {
  it("should call execute* methods in correct order across full playback lifecycle", async () => {
    // Setup: reset coordinator, mock PlayerService execute* methods
    PlayerStateCoordinator.resetInstance();
    const coordinator = PlayerStateCoordinator.getInstance();

    // Mock execute* methods to spy on calls
    const mockPlayerService = {
      executeLoadTrack: jest.fn().mockResolvedValue(undefined),
      executePlay: jest.fn().mockResolvedValue(undefined),
      executePause: jest.fn().mockResolvedValue(undefined),
      executeSeek: jest.fn().mockResolvedValue(undefined),
      executeStop: jest.fn().mockResolvedValue(undefined),
      executeSetRate: jest.fn().mockResolvedValue(undefined),
      executeSetVolume: jest.fn().mockResolvedValue(undefined),
    };
    // Wire mock service into coordinator (use existing test pattern)

    // Phase 1: Load track
    await dispatchPlayerEvent({ type: "LOAD_TRACK", payload: { libraryItemId: "item-1", ... } });
    await dispatchPlayerEvent({ type: "QUEUE_RELOADED", payload: { position: 100 } });
    // Verify: executeLoadTrack called

    // Phase 2: Play
    await dispatchPlayerEvent({ type: "PLAY" });
    await dispatchPlayerEvent({ type: "NATIVE_STATE_CHANGED", payload: { state: State.Playing } });
    // Verify: executePlay called

    // Phase 3: Progress ticks
    await dispatchPlayerEvent({ type: "NATIVE_PROGRESS_UPDATED", payload: { position: 105 } });
    await dispatchPlayerEvent({ type: "NATIVE_PROGRESS_UPDATED", payload: { position: 110 } });

    // Phase 4: Pause
    await dispatchPlayerEvent({ type: "PAUSE" });
    await dispatchPlayerEvent({ type: "NATIVE_STATE_CHANGED", payload: { state: State.Paused } });
    // Verify: executePause called

    // Phase 5: Seek (from PAUSED — preSeekState=PAUSED, no auto-PLAY)
    await dispatchPlayerEvent({ type: "SEEK", payload: { position: 200 } });
    await dispatchPlayerEvent({ type: "NATIVE_PROGRESS_UPDATED", payload: { position: 200 } });
    // Verify: executeSeek called with position 200

    // Phase 6: Play after seek
    await dispatchPlayerEvent({ type: "PLAY" });
    await dispatchPlayerEvent({ type: "NATIVE_STATE_CHANGED", payload: { state: State.Playing } });
    // Verify: executePlay called (second time)

    // Phase 7: Stop
    await dispatchPlayerEvent({ type: "STOP" });
    // Verify: executeStop called

    // Final assertions: verify call order
    const callOrder = [
      mockPlayerService.executeLoadTrack,
      mockPlayerService.executePlay,
      mockPlayerService.executePause,
      mockPlayerService.executeSeek,
      mockPlayerService.executePlay,  // second call
      mockPlayerService.executeStop,
    ];
    // Assert each was called at least the expected number of times
    expect(mockPlayerService.executeLoadTrack).toHaveBeenCalledTimes(1);
    expect(mockPlayerService.executePlay).toHaveBeenCalledTimes(2); // play + play-after-seek
    expect(mockPlayerService.executePause).toHaveBeenCalledTimes(1);
    expect(mockPlayerService.executeSeek).toHaveBeenCalledWith(200);
    expect(mockPlayerService.executeStop).toHaveBeenCalledTimes(1);
  });

  it("should auto-dispatch PLAY after SEEK when preSeekState was PLAYING", async () => {
    // Setup fresh coordinator
    PlayerStateCoordinator.resetInstance();
    const coordinator = PlayerStateCoordinator.getInstance();
    // ... mock service ...

    // Get to PLAYING state first
    await dispatchPlayerEvent({ type: "LOAD_TRACK", payload: { ... } });
    await dispatchPlayerEvent({ type: "QUEUE_RELOADED", payload: { position: 0 } });
    await dispatchPlayerEvent({ type: "PLAY" });
    await dispatchPlayerEvent({ type: "NATIVE_STATE_CHANGED", payload: { state: State.Playing } });

    // Seek from PLAYING (preSeekState = PLAYING)
    const executePlayCallsBefore = mockService.executePlay.mock.calls.length;
    await dispatchPlayerEvent({ type: "SEEK", payload: { position: 300 } });
    await new Promise(resolve => setTimeout(resolve, 50)); // let async queue drain

    // PLAY should have been auto-dispatched
    expect(mockService.executePlay.mock.calls.length).toBeGreaterThan(executePlayCallsBefore);
  });
});
```

**Important:** Follow the EXACT mock and setup patterns used in existing integration tests (PROP-01 area). Reuse existing mock infrastructure — do not duplicate mock factories. Use `await new Promise(resolve => setTimeout(resolve, 50))` to let async queue drain after dispatches.

Check existing test setup for how to inject the mock PlayerService into the coordinator. The coordinator uses `PlayerService.getInstance()` internally — tests likely mock this via jest.mock or module-level mock. Follow that pattern exactly.

Run: `npm test -- --testPathPattern="PlayerStateCoordinator" --no-coverage 2>&1 | tail -30`
</action>
<verify> - New `describe("Full lifecycle integration (CLEAN-05)")` block exists in test file - Both tests in the block pass: full lifecycle sequence and auto-PLAY-after-SEEK-from-PLAYING - `npm test -- --testPathPattern="PlayerStateCoordinator" --no-coverage 2>&1 | grep -E "PASS|FAIL"` → PASS
</verify>
<done>
Full lifecycle integration test passes. executeLoadTrack, executePlay (x2), executePause, executeSeek, executeStop are each verified called in sequence. Auto-PLAY from SEEKING when preSeekState=PLAYING is verified.
</done>
</task>

<task type="auto">
  <name>Task 2: Verify 90%+ coverage across modified files</name>
  <files>src/services/coordinator/__tests__/PlayerStateCoordinator.test.ts</files>
  <action>
Run coverage for all files modified across Phase 5:

```bash
npm test -- --coverage --collectCoverageFrom="src/services/PlayerService.ts,src/services/coordinator/PlayerStateCoordinator.ts,src/services/PlayerBackgroundService.ts,src/services/ProgressService.ts,src/stores/slices/playerSlice.ts" --no-coverage-report 2>&1 | grep -A 20 "Coverage summary"
```

Or run the full coverage report:

```bash
npm run test:coverage 2>&1 | grep -E "PlayerService|PlayerStateCoordinator|PlayerBackgroundService|ProgressService|playerSlice"
```

**Coverage targets:**

- PlayerStateCoordinator.ts: ≥ 90%
- PlayerService.ts: ≥ 90%
- playerSlice.ts: ≥ 90%
- PlayerBackgroundService.ts: ≥ 90% (may be lower due to BGS headless context code)
- ProgressService.ts: ≥ 90%

**If any file is below 90%:**

- Identify which branches/lines are uncovered
- Add targeted tests for uncovered paths (do NOT add tests that manufacture fake failure modes — only test real behaviors that are missing coverage)
- Common gaps after deletions: newly exposed else branches, error handling paths

For files that were already above 90% before Phase 5: deletions should not reduce coverage since we deleted dead code. If coverage drops, it means a deletion removed code that was exercised by tests but the test was also deleted — investigate and add back the test for the corresponding code that remained.

After any coverage additions: `npm test -- --no-coverage 2>&1 | tail -20` to confirm all tests still pass.
</action>
<verify> - Coverage report shows ≥ 90% for all five modified files - Full test suite passes
</verify>
<done>
90%+ coverage confirmed across all five files modified during Phase 5. Full test suite passes.
</done>
</task>

</tasks>

<verification>
Full test suite: `npm test -- --no-coverage 2>&1 | tail -30`

Coverage check: `npm run test:coverage 2>&1 | grep -E "PlayerService|PlayerStateCoordinator|PlayerBackground|ProgressService|playerSlice"`

New integration test exists: `grep -n "Full lifecycle integration" src/services/coordinator/__tests__/PlayerStateCoordinator.test.ts`
</verification>

<success_criteria>

- Full lifecycle integration test (LOAD→PLAY→PAUSE→SEEK→PLAY→STOP) passes
- Auto-PLAY-after-SEEK from PLAYING state is verified
- 90%+ coverage across all five modified files
- All existing tests pass with no regressions
  </success_criteria>

<output>
After completion, create `.planning/phases/05-cleanup/05-05-SUMMARY.md`
</output>
