---
phase: 05-cleanup
plan: "03"
type: execute
wave: 2
depends_on:
  - "05-01"
  - "05-02"
files_modified:
  - src/services/coordinator/PlayerStateCoordinator.ts
  - src/services/PlayerBackgroundService.ts
autonomous: true
requirements:
  - CLEAN-03

must_haves:
  truths:
    - "Coordinator's syncPositionToStore detects chapter changes and calls updateNowPlayingMetadata"
    - "BGS handlePlaybackProgressUpdated no longer calls updateNowPlayingMetadata"
    - "Lock screen chapter title still updates when chapter changes during playback"
    - "Chapter detection fires only when chapter.id actually changes (debounced by lastSyncedChapterId)"
    - "npm test passes with no regressions"
  artifacts:
    - path: "src/services/coordinator/PlayerStateCoordinator.ts"
      provides: "syncPositionToStore with chapter detection using lastSyncedChapterId"
      contains: "lastSyncedChapterId"
    - path: "src/services/PlayerBackgroundService.ts"
      provides: "handlePlaybackProgressUpdated without chapter detection or NowPlaying writes"
  key_links:
    - from: "coordinator syncPositionToStore"
      to: "store.updateNowPlayingMetadata"
      via: "chapter id comparison against lastSyncedChapterId"
      pattern: "lastSyncedChapterId"
    - from: "store.updatePosition"
      to: "store.player.currentChapter"
      via: "_updateCurrentChapter triggered synchronously by Zustand set"
      pattern: "updatePosition.*currentChapter"
---

<objective>
Move chapter detection from PlayerBackgroundService into the coordinator's syncPositionToStore. This is the prerequisite for removing isRestoringState (Plan 04). After this plan, the coordinator owns all native NowPlaying metadata writes and BGS has zero metadata write calls.

Purpose: Single source of truth for native sync. Coordinator detects chapter changes on every position tick using the existing lastSyncedChapterId debounce pattern from PROP-06.
Output: Chapter detection moves to coordinator (~+10 lines); BGS chapter code removed (~-25 lines).
</objective>

<execution_context>
@/Users/clay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/clay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-cleanup/05-RESEARCH.md
@src/services/coordinator/PlayerStateCoordinator.ts
@src/services/PlayerBackgroundService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add chapter detection to coordinator syncPositionToStore</name>
  <files>src/services/coordinator/PlayerStateCoordinator.ts</files>
  <action>
Update `syncPositionToStore()` to detect chapter changes and call `store.updateNowPlayingMetadata()` when the chapter changes.

The current implementation (after Plan 01 removes the observerMode guard):

```typescript
private syncPositionToStore(): void {
  try {
    const store = useAppStore.getState();
    store.updatePosition(this.context.position);
  } catch {
    return;
  }
}
```

Replace with:

```typescript
private syncPositionToStore(): void {
  try {
    const store = useAppStore.getState();
    store.updatePosition(this.context.position); // triggers _updateCurrentChapter synchronously

    // Detect chapter boundary crossings; debounced by lastSyncedChapterId (mirrors PROP-06)
    const currentChapterId = store.player.currentChapter?.chapter?.id?.toString() ?? null;
    if (currentChapterId !== null && currentChapterId !== this.lastSyncedChapterId) {
      this.lastSyncedChapterId = currentChapterId;
      store.updateNowPlayingMetadata().catch((err) => {
        log.error("[Coordinator] Failed to update now playing metadata on chapter change", err);
      });
    }
  } catch {
    // BGS headless context: Zustand store may not be available (PROP-05)
    return;
  }
}
```

Key points:

- `store.updatePosition()` is called FIRST — it triggers `_updateCurrentChapter` synchronously via Zustand's synchronous `set()`. By the time the next line runs, `store.player.currentChapter` reflects the updated chapter.
- `currentChapterId !== null` guard: skip if no chapter info (books without chapters).
- The `lastSyncedChapterId` field (line 94) already exists from Phase 4. No new field needed.
- `updateNowPlayingMetadata()` is fire-and-forget (`.catch()` only) — same pattern as `syncStateToStore` PROP-06.
- The try/catch BGS headless guard is RETAINED — same reason as before (PROP-05).

Update the JSDoc comment for `syncPositionToStore` to note chapter detection was added (CLEAN-03).
</action>
<verify> - `grep -A 20 "private syncPositionToStore" src/services/coordinator/PlayerStateCoordinator.ts` shows the new chapter detection block - `grep -n "lastSyncedChapterId" src/services/coordinator/PlayerStateCoordinator.ts` shows usage in both syncPositionToStore AND syncStateToStore (two references to the field in the sync methods)
</verify>
<done>
syncPositionToStore reads store.player.currentChapter after updatePosition and calls updateNowPlayingMetadata when chapter.id changes. lastSyncedChapterId debounces the call.
</done>
</task>

<task type="auto">
  <name>Task 2: Remove chapter detection and NowPlaying writes from BGS + run tests</name>
  <files>src/services/PlayerBackgroundService.ts</files>
  <action>
In `PlayerBackgroundService.handlePlaybackProgressUpdated()`, remove the chapter detection block and the periodic now-playing update block.

**Lines to remove (approximately):**

1. **previousChapter capture** (around lines 412-414) — the line that captures `previousChapter` before calling `store.updatePosition()`:

   ```typescript
   const previousChapter = store.player.currentChapter;
   ```

   Remove this line. It was only used by the chapter-change check being deleted.

2. **Chapter change check + periodic update block** (around lines 450-468):

   ```typescript
   // Check if chapter changed (non-gated update)
   const currentChapter = store.player.currentChapter;
   if (previousChapter?.chapter.id !== currentChapter?.chapter.id && currentChapter) {
     await store.updateNowPlayingMetadata();
   }

   // Periodic now playing metadata updates (gated by setting)
   const periodicUpdatesEnabled = await getPeriodicNowPlayingUpdatesEnabled();
   if (periodicUpdatesEnabled && Math.floor(event.position) % 2 === 0) {
     await store.updateNowPlayingMetadata();
   }
   ```

   Remove the entire block — all six lines and their comments.

3. **Import cleanup**: If `getPeriodicNowPlayingUpdatesEnabled` is no longer used after this removal, remove its import from the top of the file.

**After deletions:**

- `handlePlaybackProgressUpdated` should no longer reference `updateNowPlayingMetadata`, `previousChapter`, `currentChapter` (in the chapter-check sense), or `getPeriodicNowPlayingUpdatesEnabled`.
- Verify the method still handles: position update, progress persistence, session sync — just not chapter detection.

Run: `npm test -- --no-coverage 2>&1 | tail -30`

If any BGS tests verify the chapter-change → updateNowPlayingMetadata call, update them: the coordinator owns this now. Remove assertions that BGS calls updateNowPlayingMetadata on chapter change.

Add a coordinator test that verifies syncPositionToStore triggers updateNowPlayingMetadata when chapter.id changes. Place it in the existing store bridge describe block in PlayerStateCoordinator.test.ts. The test should:

1. Set up coordinator with a mock store where `updatePosition` side-effects `store.player.currentChapter` to a new chapter
2. Call `syncPositionToStore` (or dispatch `NATIVE_PROGRESS_UPDATED` to trigger it)
3. Assert `store.updateNowPlayingMetadata` was called once
4. Call again with same chapter
5. Assert `updateNowPlayingMetadata` was NOT called again (debounce)
   </action>
   <verify> - `grep -n "previousChapter\|getPeriodicNowPlayingUpdatesEnabled\|updateNowPlayingMetadata" src/services/PlayerBackgroundService.ts` → 0 results - `npm test -- --no-coverage 2>&1 | grep -E "PASS|FAIL|Tests:"` — all pass - Chapter detection test in coordinator test file exists and passes
   </verify>
   <done>
   BGS has zero NowPlaying metadata write calls. Coordinator test proves chapter detection fires on change and is debounced. All tests pass.
   </done>
   </task>

</tasks>

<verification>
Run full test suite: `npm test -- --no-coverage 2>&1 | tail -30`

Verify BGS has no NowPlaying writes:

```
grep -n "updateNowPlayingMetadata\|previousChapter\|getPeriodicNowPlayingUpdatesEnabled" src/services/PlayerBackgroundService.ts
```

→ 0 results

Verify coordinator has chapter detection:

```
grep -A 8 "syncPositionToStore" src/services/coordinator/PlayerStateCoordinator.ts | grep -c "lastSyncedChapterId"
```

→ at least 1

Verify coordinator test covers chapter detection:

```
grep -n "chapter.*detection\|lastSyncedChapterId\|syncPositionToStore" src/services/coordinator/__tests__/PlayerStateCoordinator.test.ts
```

→ finds new test
</verification>

<success_criteria>

- coordinator syncPositionToStore detects chapter changes via lastSyncedChapterId comparison
- updateNowPlayingMetadata is called on chapter change (debounced)
- BGS handlePlaybackProgressUpdated has zero NowPlaying metadata writes
- Coordinator test proves debounce behavior
- All tests pass
  </success_criteria>

<output>
After completion, create `.planning/phases/05-cleanup/05-03-SUMMARY.md`
</output>
