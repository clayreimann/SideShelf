---
phase: 04-state-propagation
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/services/PlayerService.ts
  - src/services/PlayerBackgroundService.ts
  - src/services/coordinator/PlayerStateCoordinator.ts
autonomous: true

must_haves:
  truths:
    - "PlayerService contains zero direct store writes for coordinator-owned player state fields"
    - "PlayerBackgroundService contains zero direct store writes for coordinator-owned player state fields"
    - "Retained exceptions: _setLastPauseTime (service-ephemeral), sleepTimer methods (PROP-04), setIsRestoringState (playerSlice guard)"
    - "All existing playback behaviors continue to work (no regression)"
    - "BGS chapter-change metadata call is RETAINED (CHAPTER_CHANGED event is not dispatched by any service)"
    - "BGS periodic metadata updates (2s gate) are RETAINED (settings-gated behavior)"
  artifacts:
    - path: "src/services/PlayerService.ts"
      provides: "PlayerService with direct store writes removed"
    - path: "src/services/PlayerBackgroundService.ts"
      provides: "PlayerBackgroundService with direct store writes removed"
    - path: "src/services/coordinator/PlayerStateCoordinator.ts"
      provides: "Coordinator with RELOAD_QUEUE and NATIVE_PLAYBACK_ERROR context updates"
  key_links:
    - from: "PlayerService.executeLoadTrack"
      to: "coordinator syncStateToStore"
      via: "LOAD_TRACK event triggers bridge sync (store._setCurrentTrack and _setTrackLoading removed from executeLoadTrack)"
      pattern: "dispatchPlayerEvent.*LOAD_TRACK"
    - from: "PlayerBackgroundService.handlePlaybackProgressUpdated"
      to: "coordinator syncPositionToStore"
      via: "NATIVE_PROGRESS_UPDATED event triggers bridge position sync (store.updatePosition removed from BGS)"
      pattern: "dispatchPlayerEvent.*NATIVE_PROGRESS_UPDATED"
---

<objective>
Remove all direct playerSlice write calls from PlayerService and PlayerBackgroundService that are now handled by the coordinator bridge. After this plan, the only paths writing coordinator-owned state to playerSlice are syncPositionToStore() and syncStateToStore().

Purpose: Eliminates split authority — the coordinator becomes the single source of truth for store writes.
Output: Clean service files with zero direct store writes for coordinator-owned fields.
</objective>

<execution_context>
@/Users/clay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/clay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-state-propagation/04-RESEARCH.md
@.planning/phases/04-state-propagation/04-01-SUMMARY.md
@src/services/PlayerService.ts
@src/services/PlayerBackgroundService.ts
@src/stores/slices/playerSlice.ts
@src/services/coordinator/PlayerStateCoordinator.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove direct store writes from PlayerService</name>
  <files>src/services/PlayerService.ts</files>
  <action>
Remove direct playerSlice writes that the coordinator bridge now handles. For each removal, the coordinator already receives the corresponding event and syncs to the store via syncStateToStore(). The line numbers below are approximate — verify by reading the actual code.

**REMOVE these store writes (coordinator bridge handles them):**

1. `executeLoadTrack()`:
   - Remove `store._setCurrentTrack(track)` (~line 349) — LOAD_TRACK event triggers bridge sync. BUT WAIT: the coordinator's updateContextFromEvent for LOAD_TRACK only sets `isLoadingTrack=true`, it does NOT set currentTrack. The track object is built in executeLoadTrack, not available from the event payload. **Resolution:** Keep this write for now OR dispatch the track via event. The simpler approach: keep `store._setCurrentTrack(track)` in executeLoadTrack as a RETAINED write. The coordinator doesn't have the full PlayerTrack — it only gets libraryItemId in the event. This is a necessary exception because the coordinator does not build PlayerTrack objects. Document this as retained: "coordinator does not build PlayerTrack; service sets currentTrack after building it."
   - Remove `store._setTrackLoading(true)` (~line 350) — coordinator sets `context.isLoadingTrack=true` on LOAD_TRACK, bridge syncs it
   - Remove `store.updatePosition(resumeInfo.position)` (~line 360) — POSITION_RECONCILED event triggers bridge sync
   - Remove `store._setTrackLoading(false)` in the catch block (~line 401) — this is error handling; dispatch an error event instead OR retain as error cleanup. **Resolution:** Retain for error handling — the coordinator doesn't have a dedicated error-recovery sync path for loading failures.

2. `executePlay()`:
   - RETAIN `store._setLastPauseTime(null)` (~line 464) — lastPauseTime is service-ephemeral, documented exception
   - Remove `store._setTrackLoading(false)` in the catch block (~line 468) — Retain for error handling (same as above).

3. `executeStop()`:
   - Remove `store._setCurrentTrack(null)` (~line 704) — STOP event sets context.currentTrack=null, bridge syncs it
   - Remove `store._setPlaySessionId(null)` (~line 705) — SESSION_ENDED event sets context.sessionId=null, bridge syncs it

4. `reloadTrackPlayerQueue()`:
   - Remove `store._setTrackLoading(true)` (~line 540) — RELOAD_QUEUE event is dispatched, but the coordinator doesn't set isLoadingTrack on RELOAD_QUEUE. **Resolution:** Add RELOAD_QUEUE handling to coordinator's updateContextFromEvent: set `this.context.isLoadingTrack = true`. Then remove the direct write. Do this in the coordinator file as part of this task.
   - Remove `store.updatePosition(resumeInfo.position)` (~line 573) — POSITION_RECONCILED handles this
   - Remove `store._setTrackLoading(false)` in the finally block (~line 613) — QUEUE_RELOADED event already sets isLoadingTrack=false in coordinator, bridge syncs. Retain only the error path.
   - RETAIN `store.setIsRestoringState(true/false)` calls — isRestoringState is playerSlice-local, Phase 5 removes it
   - RETAIN `store._updateCurrentChapter(resumeInfo.position)` (~line 579) — chapter calculation lives in playerSlice, not coordinator

5. `buildTrackList()`:
   - Remove `store._setPlaySessionId(playSession.id)` (~line 747) — dispatch SESSION_CREATED event instead: `dispatchPlayerEvent({ type: "SESSION_CREATED", payload: { sessionId: playSession.id } })`. The coordinator already handles SESSION_CREATED in updateContextFromEvent.
   - Remove `store._setPlaySessionId(null)` (~line 767) — dispatch SESSION_ENDED event instead: `dispatchPlayerEvent({ type: "SESSION_ENDED", payload: { sessionId: store.player.currentPlaySessionId || "" } })`. Wait — SESSION_ENDED is semantically for ending a session, not clearing a stale ID. **Resolution:** This is clearing a stale streaming session ID before local playback. Keep the direct write — it's a cleanup step, not a coordinator-mediated transition.

6. `rebuildCurrentTrackIfNeeded()`:
   - Remove `store._setPlaySessionId(null)` (~line 511) — same cleanup pattern as above. **Resolution:** Retain — stale session cleanup, not coordinator-mediated.

7. `reconcileTrackPlayerState()`:
   - Remove `store.updatePosition(...)` calls (~lines 1166, 1172) — reconciliation should dispatch events, but this is a legacy reconciliation method. **Resolution:** Retain for now — reconcileTrackPlayerState is a legacy method that Phase 5 may remove entirely. Don't refactor it in Phase 4.
   - Remove `store.updatePlayingState(tpIsPlaying)` (~line 1205) — same: retain in legacy method

8. `syncPositionFromDatabase()`:
   - Remove `store.updatePosition(session.currentTime)` (~line 1277) — **Resolution:** Retain — this is an explicit sync-from-DB method, not a coordinator-mediated path. Phase 5 may route this through coordinator.

9. `syncStoreWithTrackPlayer()`:
   - Remove `store.updatePosition(...)` and `store._setCurrentTrack(...)` — **Resolution:** Retain — legacy reconciliation method.

10. `restorePlayerServiceFromSession()`:
    - The `store._setCurrentTrack(track)` (~line 966) — RETAIN. Same reason as executeLoadTrack: coordinator doesn't build PlayerTrack.

11. `refreshFilePathsAfterContainerChange()`:
    - The `store._setCurrentTrack(updatedTrack)` (~line 1478) — RETAIN. Cover URI refresh is a UI concern, not coordinator state.

**Summary of ACTUAL removals from PlayerService:**

- `store._setTrackLoading(true)` in executeLoadTrack (line ~350)
- `store.updatePosition(resumeInfo.position)` in executeLoadTrack (line ~360)
- `store._setCurrentTrack(null)` in executeStop (line ~704)
- `store._setPlaySessionId(null)` in executeStop (line ~705)
- `store.updatePosition(resumeInfo.position)` in reloadTrackPlayerQueue (line ~573)

**Also in coordinator (small fix for this task):**

- Add `RELOAD_QUEUE` case to `updateContextFromEvent`: `this.context.isLoadingTrack = true;`

**Store writes RETAINED in PlayerService (documented exceptions):**

- `store._setCurrentTrack(track)` in executeLoadTrack, restorePlayerServiceFromSession, refreshFilePathsAfterContainerChange — coordinator cannot build PlayerTrack
- `store._setLastPauseTime(...)` in executePause/executePlay — service-ephemeral state
- `store._setTrackLoading(false)` in error catch blocks — error cleanup
- `store.setIsRestoringState(...)` — playerSlice-local guard
- `store._updateCurrentChapter(...)` — chapter calculation lives in playerSlice
- `store._setPlaySessionId(...)` in buildTrackList/rebuildCurrentTrackIfNeeded — stale session cleanup
- All writes in reconcileTrackPlayerState, syncPositionFromDatabase, syncStoreWithTrackPlayer — legacy reconciliation methods (Phase 5 candidates)
  </action>
  <verify>
  Run: `npx tsc --noEmit 2>&1 | head -30` — no new TypeScript errors.
  Run: `npm test -- --testPathPattern="PlayerService" --passWithNoTests` — existing tests pass.
  </verify>
  <done>
  PlayerService has 5 direct store writes removed. Coordinator-owned fields (position on POSITION_RECONCILED, isLoadingTrack on LOAD_TRACK, currentTrack/sessionId on STOP) now flow through the bridge. Retained writes are documented with rationale.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Remove direct store writes from PlayerBackgroundService</name>
  <files>src/services/PlayerBackgroundService.ts, src/services/coordinator/PlayerStateCoordinator.ts</files>
  <action>
Remove direct playerSlice writes from BGS that the coordinator bridge now handles. The BGS already dispatches events to the coordinator (Phase 2), so the coordinator receives every event and syncs to the store.

**IMPORTANT: CHAPTER_CHANGED dispatch path verification**

Before removing ANY chapter-change metadata call, verify whether `CHAPTER_CHANGED` is actually dispatched to the coordinator by any service. Run:

```bash
grep -rn "dispatchPlayerEvent.*CHAPTER_CHANGED" src/
```

**If this grep returns ZERO results** (which is the expected case based on current codebase analysis — `CHAPTER_CHANGED` is defined as a no-op event type in the coordinator's transition table and handled in `updateContextFromEvent`, but NO service actually dispatches it):

- **DO NOT remove** the `store.updateNowPlayingMetadata()` call at the chapter-change path (~line 475). The coordinator bridge's `syncStateToStore()` chapter-change detection (via `lastSyncedChapterId`) will never fire for chapter changes because `CHAPTER_CHANGED` is never dispatched, so the bridge path is dead for this purpose.
- The BGS chapter-change metadata call is the ONLY path that updates lock screen chapter titles on chapter transitions. Removing it would silently break lock screen metadata.
- Mark this with a comment: `// RETAINED: CHAPTER_CHANGED event is not dispatched by any service — bridge cannot handle this yet (Phase 5 candidate)`

**If the grep DOES return results** (meaning a dispatch was added in Plan 01 or elsewhere):

- It is safe to remove the BGS chapter-change metadata call
- The coordinator bridge's `lastSyncedChapterId` tracking will handle it

**REMOVE these store writes:**

1. `handlePlaybackStateChanged()`:
   - Remove `store._setTrackLoading(false)` (~line 372) when state===Playing — coordinator sets isLoadingTrack=false via NATIVE_STATE_CHANGED bridge sync
   - Remove `store.updatePosition(progress.position)` (~line 384) — NATIVE_STATE_CHANGED bridge sync handles position
   - Remove `store.updatePlayingState(isPlaying)` (~line 385) — NATIVE_STATE_CHANGED bridge sync handles isPlaying

2. `handlePlaybackProgressUpdated()`:
   - Remove ALL `store.updatePosition(...)` calls. There are many of them scattered throughout this function:
     - Main path: `store.updatePosition(updatedSession.currentTime)` (~line 461)
     - Fallback: `store.updatePosition(event.position)` (~line 465)
     - After rehydration: `store.updatePosition(updatedSession.currentTime)` (~line 608)
     - After new session: `store.updatePosition(newSession.currentTime)` (~line 652)
     - Error fallback: `store.updatePosition(event.position)` (~line 660)
     - No username fallback: `store.updatePosition(event.position)` (~line 666)
     - Failed rehydration fallback: `store.updatePosition(event.position)` (~line 673)
     - No IDs fallback: `store.updatePosition(event.position)` (~line 678)
     - No track fallback: `store.updatePosition(event.position)` (~line 682)
   - The coordinator already receives NATIVE_PROGRESS_UPDATED and syncs position via syncPositionToStore(). All these redundant writes can go.
   - **RETAIN** `store.updateNowPlayingMetadata()` at the chapter-change path (~line 475) — see CHAPTER_CHANGED verification above. This call must stay because CHAPTER_CHANGED is never dispatched to the coordinator, so the bridge cannot handle chapter-change metadata.
   - **RETAIN** `store.updateNowPlayingMetadata()` at the periodic path (~line 483, settings-gated `% 2 === 0`) — coordinator bridge doesn't replicate periodic metadata; only chapter-change metadata.
   - RETAIN `store._setLastPauseTime(pauseTime)` (~line 515) in sleep timer section — service-ephemeral exception
   - RETAIN `store.cancelSleepTimer()` (~line 513) — sleep timer is PROP-04 exception

3. `handlePlaybackError()`:
   - Remove `store._setTrackLoading(false)` (~line 838) — the coordinator should handle this via an error event. BUT: the coordinator receives NATIVE_PLAYBACK_ERROR but doesn't set isLoadingTrack=false in updateContextFromEvent for that event type. **Resolution:** Add `this.context.isLoadingTrack = false;` to the NATIVE_PLAYBACK_ERROR case in coordinator's updateContextFromEvent. Then remove the BGS write.

4. `handleRemoteJumpForward()`:
   - Remove `store.updatePosition(newPosition)` (~line 186) — SEEK event dispatched, coordinator syncs position

5. `handleRemoteJumpBackward()`:
   - Remove `store.updatePosition(newPosition)` (~line 235) — SEEK event dispatched, coordinator syncs position

6. `handleRemoteSeek()`:
   - Remove `store.updatePosition(event.position)` (~line 300) — SEEK event dispatched, coordinator syncs position

**Also in coordinator (small fixes for this task):**

- Add `NATIVE_PLAYBACK_ERROR` case to updateContextFromEvent: add `this.context.isLoadingTrack = false;` (alongside the existing lastError assignment)
- No other coordinator changes needed

**Summary of ACTUAL removals from BGS:**

- 3 writes in handlePlaybackStateChanged (isLoadingTrack, position, isPlaying)
- ~9 writes of store.updatePosition in handlePlaybackProgressUpdated
- 1 write in handlePlaybackError (isLoadingTrack)
- 3 writes in handleRemoteJumpForward/Backward/Seek (position)

**Store writes RETAINED in BGS (documented exceptions):**

- `store._setLastPauseTime(pauseTime)` — service-ephemeral
- `store.cancelSleepTimer()` — PROP-04 exception
- `store.updateNowPlayingMetadata()` chapter-change path — CHAPTER_CHANGED not dispatched; bridge cannot handle (Phase 5 candidate)
- `store.updateNowPlayingMetadata()` periodic path (settings-gated, `% 2 === 0`) — coordinator bridge doesn't replicate periodic metadata
  </action>
  <verify>
  Run: `npx tsc --noEmit 2>&1 | head -30` — no new TypeScript errors.
  Run: `npm test -- --testPathPattern="PlayerService|PlayerStateCoordinator" --passWithNoTests` — existing tests pass.
  Grep for removed patterns: `grep -n "store\.updatePosition\|store\.updatePlayingState\|store\._setTrackLoading" src/services/PlayerBackgroundService.ts` — should return zero results (except the retained periodic metadata path which doesn't match these patterns).
  Grep to confirm retained metadata calls: `grep -n "updateNowPlayingMetadata" src/services/PlayerBackgroundService.ts` — should return exactly 2 results (chapter-change path and periodic path).
  </verify>
  <done>
  PlayerBackgroundService has ~16 direct store writes removed. Position, isPlaying, and isLoadingTrack are now written exclusively by the coordinator bridge. Retained writes are limited to lastPauseTime (ephemeral), cancelSleepTimer (PROP-04), and BOTH updateNowPlayingMetadata calls (chapter-change retained because CHAPTER_CHANGED is never dispatched; periodic retained as settings-gated).
  </done>
  </task>

</tasks>

<verification>
1. `npx tsc --noEmit` — no new TypeScript errors across all files
2. `npm test` — all existing tests pass
3. Grep confirms no coordinator-owned store writes remain in services:
   - `grep -c "store\.updatePosition\|store\.updatePlayingState\|store\._setTrackLoading" src/services/PlayerBackgroundService.ts` — should return 0
   - `grep -c "store\._setTrackLoading" src/services/PlayerService.ts` — should return only error-path instances
4. Grep confirms retained exceptions still exist:
   - `grep -c "_setLastPauseTime" src/services/PlayerService.ts` — should be > 0
   - `grep -c "cancelSleepTimer\|_setLastPauseTime" src/services/PlayerBackgroundService.ts` — should be > 0
5. Grep confirms chapter-change metadata retained:
   - `grep -c "updateNowPlayingMetadata" src/services/PlayerBackgroundService.ts` — should be 2 (chapter-change + periodic)
</verification>

<success_criteria>

- Zero direct store writes for coordinator-owned fields in PlayerBackgroundService
- PlayerService direct writes reduced to documented exceptions (PlayerTrack building, error cleanup, lastPauseTime, legacy reconciliation methods)
- BGS chapter-change and periodic updateNowPlayingMetadata calls retained
- All existing tests pass without modification
- TypeScript compiles without new errors
  </success_criteria>

<output>
After completion, create `.planning/phases/04-state-propagation/04-02-SUMMARY.md`
</output>
