---
phase: 04-state-propagation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/coordinator/PlayerStateCoordinator.ts
  - src/services/coordinator/__tests__/PlayerStateCoordinator.test.ts
autonomous: true

must_haves:
  truths:
    - "Coordinator bridge writes player state to Zustand store after allowed transitions"
    - "Position-only sync fires on 1Hz NATIVE_PROGRESS_UPDATED events (not full sync)"
    - "Full state sync fires on structural transitions (track, session, playing state)"
    - "syncToStore is skipped when observerMode is true"
    - "syncToStore fails gracefully in Android BGS headless context (try/catch guard)"
    - "Sleep timer, lastPauseTime, isRestoringState, isModalVisible are never overwritten by sync"
  artifacts:
    - path: "src/services/coordinator/PlayerStateCoordinator.ts"
      provides: "syncPositionToStore() and syncStateToStore() bridge methods + handleEvent wiring"
      contains: "syncPositionToStore"
    - path: "src/services/coordinator/__tests__/PlayerStateCoordinator.test.ts"
      provides: "Bridge unit tests for sync methods"
      contains: "syncPositionToStore"
  key_links:
    - from: "PlayerStateCoordinator.handleEvent"
      to: "syncPositionToStore / syncStateToStore"
      via: "called inside if (validation.allowed && !this.observerMode) block"
      pattern: "syncPositionToStore|syncStateToStore"
    - from: "syncStateToStore"
      to: "useAppStore.getState()"
      via: "Zustand getState() for outside-React writes"
      pattern: "useAppStore\\.getState\\(\\)"
---

<objective>
Build the coordinator-to-store bridge: add syncPositionToStore() and syncStateToStore() methods to PlayerStateCoordinator, and wire them into handleEvent() so the coordinator propagates its internal context to playerSlice after every allowed transition.

Purpose: This is the foundation of Phase 4. Once the bridge exists and is tested, Plan 02 can safely remove direct store writes from services.
Output: Coordinator with working bridge methods, unit tests proving correct sync behavior.
</objective>

<execution_context>
@/Users/clay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/clay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-state-propagation/04-RESEARCH.md
@src/services/coordinator/PlayerStateCoordinator.ts
@src/stores/slices/playerSlice.ts
@src/types/coordinator.ts
@src/services/coordinator/__tests__/PlayerStateCoordinator.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add syncPositionToStore and syncStateToStore bridge methods</name>
  <files>src/services/coordinator/PlayerStateCoordinator.ts</files>
  <action>
Add two private methods to PlayerStateCoordinator, placed in a new section after the Position Reconciliation section (before Event Bus Integration):

```
// ============================================================================
// Store Bridge (Phase 4: State Propagation)
// ============================================================================
```

**syncPositionToStore()** — high-frequency, called on NATIVE_PROGRESS_UPDATED (1Hz):

- Guard: `if (this.observerMode) return;`
- Wrap `useAppStore.getState()` in try/catch, return on failure (BGS headless context guard — PROP-05)
- Call ONLY `store.updatePosition(this.context.position)` — nothing else
- This is the minimal path to prevent Zustand selector re-evaluation storms (PROP-02/PROP-03)

**syncStateToStore()** — low-frequency, called on structural transitions:

- Guard: `if (this.observerMode) return;`
- Wrap `useAppStore.getState()` in try/catch, return on failure (BGS headless context guard — PROP-05)
- Sync these coordinator context fields to store mutators:
  - `store._setCurrentTrack(this.context.currentTrack)`
  - `store.updatePlayingState(this.context.isPlaying)`
  - `store.updatePosition(this.context.position)`
  - `store._setTrackLoading(this.context.isLoadingTrack)`
  - `store._setSeeking(this.context.isSeeking)`
  - `store._setPlaybackRate(this.context.playbackRate)`
  - `store._setVolume(this.context.volume)`
  - `store._setPlaySessionId(this.context.sessionId)`
- Do NOT sync: `lastPauseTime` (not in StateContext, service-ephemeral), `sleepTimer` (PROP-04 exception), `isRestoringState` (playerSlice-local guard), `isModalVisible` (UI-only), `initialized` (lifecycle)
- After sync, check if chapter changed and call updateNowPlayingMetadata:
  - Track previous chapter ID in a private field `private lastSyncedChapterId: string | null = null;`
  - After sync, if `this.context.currentChapter` exists and its chapter.id differs from `lastSyncedChapterId`, call `store.updateNowPlayingMetadata()` (async, fire-and-forget with .catch)
  - Update `lastSyncedChapterId` after the call
  - This preserves PROP-06 (metadata debounce) — only fires on actual chapter change, not every structural sync

**Wire into handleEvent():**
In the `if (validation.allowed)` block, AFTER the existing `if (!this.observerMode)` block that calls `executeTransition`, add sync calls. The placement must be:

1. Context is already updated (updateContextFromEvent ran)
2. State is already advanced (this.context.currentState = nextState)
3. executeTransition has already run (side effects complete)

Add this logic after the `await this.executeTransition(event, nextState);` line, still inside `if (!this.observerMode)`:

```typescript
// Sync coordinator state to Zustand store (Phase 4: State Propagation)
if (event.type === "NATIVE_PROGRESS_UPDATED") {
  this.syncPositionToStore();
} else {
  this.syncStateToStore();
}
```

This ensures:

- 1Hz position events use the lightweight path
- All other allowed events (PLAY, PAUSE, STOP, LOAD_TRACK, NATIVE_STATE_CHANGED, SEEK, SET_RATE, SET_VOLUME, SESSION_CREATED, SESSION_ENDED, NATIVE_TRACK_CHANGED, CHAPTER_CHANGED, QUEUE_RELOADED, etc.) use the full sync path
- Rejected transitions never sync (already outside the allowed block)
- Observer mode never syncs (already inside !observerMode block)

Initialize `lastSyncedChapterId` to `null` in the constructor alongside other private fields.
</action>
<verify>
Run: `npx tsc --noEmit 2>&1 | head -30` — no new TypeScript errors in coordinator file.
Run: `npm test -- --testPathPattern="PlayerStateCoordinator" --passWithNoTests` — existing tests still pass.
</verify>
<done>
PlayerStateCoordinator has syncPositionToStore() and syncStateToStore() methods. handleEvent() calls the appropriate sync method after every allowed transition when not in observer mode. Observer mode guard and BGS try/catch guard are present in both methods.
</done>
</task>

<task type="auto">
  <name>Task 2: Add bridge unit tests</name>
  <files>src/services/coordinator/__tests__/PlayerStateCoordinator.test.ts</files>
  <action>
Add a new `describe("Store Bridge (Phase 4)")` block to the existing coordinator test file. Tests verify bridge behavior through the public API (dispatch events, check store state).

The test file already mocks `useAppStore` — use the existing mock infrastructure. If the mock doesn't expose `getState()` properly for the bridge, update the mock to return an object with the playerSlice mutator methods as jest.fn() spies.

**Tests to add:**

1. **"syncPositionToStore updates store position on NATIVE_PROGRESS_UPDATED"**
   - Dispatch LOAD_TRACK + PLAY to reach PLAYING state
   - Dispatch NATIVE_PROGRESS_UPDATED with position: 42.5, duration: 3600
   - Assert `store.updatePosition` was called with 42.5
   - Assert `store._setCurrentTrack` was NOT called (position-only path)

2. **"syncStateToStore updates all fields on structural transition"**
   - Dispatch LOAD_TRACK event
   - Assert `store._setTrackLoading(true)` was called
   - Assert `store._setCurrentTrack`, `store.updatePlayingState`, `store.updatePosition` were also called

3. **"syncToStore skipped in observer mode"**
   - Set coordinator to observer mode: `coordinator.setObserverMode(true)`
   - Dispatch NATIVE_PROGRESS_UPDATED
   - Assert `store.updatePosition` was NOT called by the bridge (context still updates, but store does not)

4. **"syncToStore does not overwrite sleepTimer or lastPauseTime"**
   - Verify that neither `store.setSleepTimer`, `store.cancelSleepTimer`, nor `store._setLastPauseTime` are called during any sync operation
   - Dispatch several events (PLAY, PAUSE, NATIVE_PROGRESS_UPDATED)
   - Assert those methods were never called by the bridge (lastPauseTime IS called by executePause, but that's the service path, not the bridge)

5. **"syncToStore calls updateNowPlayingMetadata on chapter change"**
   - Set up coordinator in PLAYING state
   - Dispatch CHAPTER_CHANGED with a new chapter
   - Assert `store.updateNowPlayingMetadata` was called
   - Dispatch another event that does NOT change the chapter
   - Assert `store.updateNowPlayingMetadata` was NOT called again

6. **"syncToStore handles BGS context gracefully (getState throws)"**
   - Mock `useAppStore.getState` to throw an error
   - Dispatch NATIVE_PROGRESS_UPDATED
   - Assert no crash occurs, event still processes normally

Use `await new Promise(resolve => setTimeout(resolve, 50))` after dispatch calls to let the async queue drain (established pattern from Phase 2/3 tests).
</action>
<verify>
Run: `npm test -- --testPathPattern="PlayerStateCoordinator" --verbose` — all tests pass including new bridge tests.
</verify>
<done>
Six bridge tests pass, covering: position-only sync, full state sync, observer mode guard, sleep timer / lastPauseTime exclusion, chapter-change metadata update, and BGS error handling.
</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — no new TypeScript errors
2. `npm test -- --testPathPattern="PlayerStateCoordinator"` — all tests pass
3. Grep confirms syncPositionToStore and syncStateToStore exist in coordinator: `grep -n "syncPositionToStore\|syncStateToStore" src/services/coordinator/PlayerStateCoordinator.ts`
4. Grep confirms observerMode guard in both sync methods: `grep -A1 "syncPositionToStore\|syncStateToStore" src/services/coordinator/PlayerStateCoordinator.ts | grep observerMode`
</verification>

<success_criteria>

- syncPositionToStore() and syncStateToStore() exist on PlayerStateCoordinator
- handleEvent() calls the appropriate sync method after allowed transitions
- Observer mode guard prevents sync when observerMode=true
- BGS try/catch guard prevents crash when Zustand is unavailable
- Six new tests pass covering all bridge behaviors
- Existing coordinator tests remain green
  </success_criteria>

<output>
After completion, create `.planning/phases/04-state-propagation/04-01-SUMMARY.md`
</output>
